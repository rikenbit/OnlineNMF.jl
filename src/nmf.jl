"""
    nmf(;input::AbstractString="", outdir::Union{Nothing,AbstractString}=nothing, alpha::Number=1, beta::Number=2, graphv::Number=0, l1u::Number=eps(Float32), l1v::Number=eps(Float32), l2u::Number=eps(Float32), l2v::Number=eps(Float32), dim::Number=3, numepoch::Number=5, chunksize::Number=1, algorithm::AbstractString="frobenius", lower::Number=0, upper::Number=1.0f+38, initU::Union{Nothing,AbstractString}=nothing, initV::Union{Nothing,AbstractString}=nothing, initL::Union{Nothing,AbstractString}=nothing, logdir::Union{Nothing,AbstractString}=nothing)

    Non-negative Matrix Factorization (NMF).

Input Arguments
---------
- `input` : Julia Binary file generated by `OnlinePCA.csv2bin` function.
- `outdir` : The directory user want to save the result.
- `alpha` : The parameter of Alpha-divergence.
- `beta` : The parameter of Beta-divergence.
- `graphv` : Graph regularization parameter for the factor matrix V.
- `l1u` : L1-regularization parameter for the factor matrix U.
- `l1v` : L1-regularization parameter for the factor matrix V.
- `l2u` : L2-regularization parameter for the factor matrix U.
- `l2v` : L2-regularization parameter for the factor matrix V.
- `dim` : The number of dimension of NMF.
- `numepoch` : The number of epochs.
- `chunksize: The number of rows reading at once (e.g. 5000).
- `algorithm`: Update Algorithm. `frobenius`, `kl`, `is`, `pearson`, `hellinger`, `neyman`, `alpha`, and `beta` are available.
- `lower` : Stopping Criteria (When the relative change of error is below this value, the calculation is terminated).
- `upper` : Stopping Criteria (When the relative change of error is above this value, the calculation is terminated).
- `initU` : The CSV file saving the initial values of factor matrix U.
- `initV` : The CSV file saving the initial values of factor matrix V.
- `initL` : The CSV file saving the initial values of graph laplacian L.
- `logdir` : The directory where intermediate files are saved in every epoch.

Output Arguments
---------
- `U` : Factor matrix (No. rows of the data matrix × dim)
- `V` : Factor matrix (No. columns of the data matrix × dim)
- stop : Whether the calculation is converged
"""
function nmf(;
    input::AbstractString="",
    outdir::Union{Nothing,AbstractString}=nothing,
    alpha::Number=1,
    beta::Number=2,
    graphv::Number=0,
    l1u::Number=eps(Float32),
    l1v::Number=eps(Float32),
    l2u::Number=eps(Float32),
    l2v::Number=eps(Float32),
    dim::Number=3,
    numepoch::Number=5,
    chunksize::Number=1,
    algorithm::AbstractString="frobenius",
    lower::Number=0,
    upper::Number=1.0f+38,
    initU::Union{Nothing,AbstractString}=nothing,
    initV::Union{Nothing,AbstractString}=nothing,
    initL::Union{Nothing,AbstractString}=nothing,
    logdir::Union{Nothing,AbstractString}=nothing,
)
    # Initial Setting
    nmfmodel = NMF()
    alpha,
    beta,
    graphv,
    l1u,
    l1v,
    l2u,
    l2v,
    U,
    V,
    L,
    N,
    M,
    numepoch,
    chunksize,
    algorithm_type,
    logdir,
    lower,
    upper = init_nmf(
        input,
        alpha,
        beta,
        graphv,
        l1u,
        l1v,
        l2u,
        l2v,
        dim,
        numepoch,
        chunksize,
        algorithm,
        initU,
        initV,
        initL,
        logdir,
        lower,
        upper
    )
    # Perform NMF
    out = each_nmf(
        input,
        alpha,
        beta,
        graphv,
        l1u,
        l1v,
        l2u,
        l2v,
        U,
        V,
        L,
        N,
        M,
        numepoch,
        chunksize,
        algorithm_type,
        logdir,
        lower,
        upper,
        nmfmodel,
    )
    if outdir isa String
        mkpath(outdir)
        output(outdir, out, lower)
    end
    return out
end

function each_nmf(
    input,
    alpha,
    beta,
    graphv,
    l1u,
    l1v,
    l2u,
    l2v,
    U,
    V,
    L,
    N,
    M,
    numepoch,
    chunksize,
    algorithm_type,
    logdir,
    lower,
    upper,
    nmfmodel,
)
    # If not 0 the calculation is converged
    stop = 0
    s = 1
    # Each epoch s
    progress = Progress(numepoch)
    while (stop == 0 && s <= numepoch)
        next!(progress)
        # Update U
        U = update_U(input, N, M, U, V, alpha, beta, l1u, l2u, chunksize, algorithm_type)
        # NaN
        checkNaN(U)
        # Update V
        V = update_V(input, N, M, U, V, L, alpha, beta, graphv, l1v,
            l2v, chunksize, algorithm_type)
        # NaN
        checkNaN(V)
        # Normalization
        norm = sum(U, dims=1)
        U = U ./ norm
        V = V .* norm
        # save log file
        if logdir isa String
            stop = outputlog(s, input, logdir, U, V, lower, upper, nmfmodel, chunksize)
        end
        s += 1
    end
    # Return
    return U, V, stop
end

# Update U (Alpha-divergence)
function update_U(input, N, M, U, V, alpha, beta, l1u, l2u, chunksize, algorithm_type::ALPHA)
    numer = update_U_numer_ALPHA(input, N, M, U, V, alpha, chunksize)
    denom = update_U_denom_ALPHA(N, V)
    update_factor = ifelse.(denom .== 0, 1.0, (numer ./ denom) .^ (1 / alpha))
    U .* update_factor
end

function update_U_numer_ALPHA(input, N, M, U, V, alpha, chunksize)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    numer = zeros(size(U))
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        read!(stream, tmpN)
        read!(stream, tmpM)
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            buffer = zeros(UInt32, batch_size * M)
            read!(stream, buffer)
            X_chunk = permutedims(reshape(buffer, M, batch_size))
            U_chunk = @view U[n:n+batch_size-1, :]
            @turbo numer[n:n+batch_size-1, :] = ((X_chunk ./ (U_chunk * V')) .^ alpha) * V
            n += batch_size
        end
        close(stream)
    end
    return numer
end

function update_U_denom_ALPHA(N, V)
    @turbo ones(Int64(N), 1) * sum(V, dims=1)
end

# Update U (Beta-divergence)
function update_U(input, N, M, U, V, alpha, beta, l1u, l2u, chunksize, algorithm_type::BETA)
    numer = update_U_numer_BETA(input, N, M, U, V, beta, chunksize)
    denom = update_U_denom_BETA(N, U, V, beta, l1u, l2u, chunksize)
    update_factor = ifelse.(denom .== 0, 1.0, (numer ./ denom) .^ rho(beta))
    U .* update_factor
end

function update_U_numer_BETA(input, N, M, U, V, beta, chunksize)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    numer = zeros(size(U))
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        read!(stream, tmpN)
        read!(stream, tmpM)
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            buffer = zeros(UInt32, batch_size * M)
            read!(stream, buffer)
            X_chunk = permutedims(reshape(buffer, M, batch_size))
            U_chunk = @view U[n:n+batch_size-1, :]
            @turbo numer[n:n+batch_size-1, :] =
                (((U_chunk * V') .^ (beta - 2)) .* X_chunk) * V
            n += batch_size
        end
        close(stream)
    end
    return numer
end

function update_U_denom_BETA(N, U, V, beta, l1u, l2u, chunksize)
    denom = zeros(size(U))
    n = 1
    while n <= N
        batch_size = min(chunksize, N - n + 1)
        U_chunk = @view U[n:n+batch_size-1, :]
        @turbo denom[n:n+batch_size-1, :] =
            ((U_chunk * V') .^ (beta - 1)) * V .+ l1u + l2u .* U_chunk
        n += batch_size
    end
    return denom
end

# Update V (Alpha-divergence)
function update_V(
    input,
    N,
    M,
    U,
    V,
    L,
    alpha,
    beta,
    graphv,
    l1v,
    l2v,
    chunksize,
    algorithm_type::ALPHA,
)
    numer = update_V_numer_ALPHA(input, N, M, U, V, alpha, chunksize)
    denom = update_V_denom_ALPHA(M, U)
    update_factor = ifelse.(denom .== 0, 1.0, (numer ./ denom) .^ (1 / alpha))
    V .* update_factor
end

function update_V_numer_ALPHA(input, N, M, U, V, alpha, chunksize)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    numer = zeros(size(V))
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        read!(stream, tmpN)
        read!(stream, tmpM)
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            buffer = zeros(UInt32, batch_size * M)
            read!(stream, buffer)
            X_chunk = permutedims(reshape(buffer, M, batch_size))
            U_chunk = @view U[n:n+batch_size-1, :]
            @turbo numer .+= ((X_chunk ./ (U_chunk * V')) .^ alpha)' * U_chunk
            n += batch_size
        end
        close(stream)
    end
    return numer
end

function update_V_denom_ALPHA(M, U)
    @turbo ones(Int64(M), 1) * sum(U, dims=1)
end

# Update V (Beta-divergence)
function update_V(
    input,
    N,
    M,
    U,
    V,
    L,
    alpha,
    beta,
    graphv,
    l1v,
    l2v,
    chunksize,
    algorithm::BETA,
)
    numer = update_V_numer_BETA(input, N, M, U, V, beta, chunksize)
    denom = update_V_denom_BETA(N, U, V, L, beta, graphv, l1v, l2v, chunksize)
    update_factor = ifelse.(denom .== 0, 1.0, (numer ./ denom) .^ rho(beta))
    V .* update_factor
end

function update_V_numer_BETA(input, N, M, U, V, beta, chunksize)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    numer = zeros(size(V))
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        read!(stream, tmpN)
        read!(stream, tmpM)
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            buffer = zeros(UInt32, batch_size * M)
            read!(stream, buffer)
            X_chunk = permutedims(reshape(buffer, M, batch_size))
            U_chunk = @view U[n:n+batch_size-1, :]
            @turbo numer .+= ((U_chunk * V') .^ (beta - 2) .* X_chunk)' * U_chunk
            n += batch_size
        end
        close(stream)
    end
    return numer
end

function update_V_denom_BETA(N, U, V, L, beta, graphv, l1v, l2v, chunksize)
    denom = zeros(size(V))
    n = 1
    while n <= N
        batch_size = min(chunksize, N - n + 1)
        U_chunk = @view U[n:n+batch_size-1, :]
        @turbo denom .+=
            ((U_chunk * V') .^ (beta - 1))' * U_chunk .+ l1v + l2v .* V + graphv .* (L * V)
        n += batch_size
    end
    return denom
end

# Initialization step in NMF
function init_nmf(
    input::AbstractString,
    alpha::Number,
    beta::Number,
    graphv::Number,
    l1u::Number,
    l1v::Number,
    l2u::Number,
    l2v::Number,
    dim::Number,
    numepoch::Number,
    chunksize::Number,
    algorithm::AbstractString,
    initU::Union{Nothing,AbstractString},
    initV::Union{Nothing,AbstractString},
    initL::Union{Nothing,AbstractString},
    logdir::Union{Nothing,AbstractString},
    lower::Number,
    upper::Number
)
    # Initialization
    N, M = nm(input)
    alpha = convert(Float32, alpha)
    beta = convert(Float32, beta)
    graphv = convert(Float32, graphv)
    l1u = convert(Float32, l1u)
    l1v = convert(Float32, l1v)
    l2u = convert(Float32, l2u)
    l2v = convert(Float32, l2v)
    dim = convert(Int64, dim)
    numepoch = convert(Int64, numepoch)
    chunksize = convert(Int64, chunksize)
    lower = convert(Float32, lower)
    upper = convert(Float32, upper)
    # Argument Check
    # Check matrix dimensions (single row/column is meaningless for NMF)
    if N == 1
        throw(ArgumentError("Input matrix has only 1 row. NMF requires at least 2 rows."))
    end
    if M == 1
        throw(ArgumentError("Input matrix has only 1 column. NMF requires at least 2 columns."))
    end
    # Check non-negative parameters
    if graphv < 0
        throw(ArgumentError("graphv must be non-negative, got $graphv"))
    end
    if l1u < 0
        throw(ArgumentError("l1u must be non-negative, got $l1u"))
    end
    if l1v < 0
        throw(ArgumentError("l1v must be non-negative, got $l1v"))
    end
    if l2u < 0
        throw(ArgumentError("l2u must be non-negative, got $l2u"))
    end
    if l2v < 0
        throw(ArgumentError("l2v must be non-negative, got $l2v"))
    end
    if dim < 1
        throw(ArgumentError("dim must be positive, got $dim"))
    end
    if numepoch < 1
        throw(ArgumentError("numepoch must be positive, got $numepoch"))
    end
    if chunksize < 1
        throw(ArgumentError("chunksize must be positive, got $chunksize"))
    end
    if lower < 0
        throw(ArgumentError("lower must be non-negative, got $lower"))
    end
    if upper < 0
        throw(ArgumentError("upper must be non-negative, got $upper"))
    end
    # Check dim vs matrix size
    if min(N, M) < dim
        throw(ArgumentError("dim ($dim) must be <= min(N, M) = $(min(N, M))"))
    end
    # Initialization of U and V
    U = load_or_random(initU, N, dim)
    V = load_or_random(initV, M, dim)
    L = load_or_random(initL, M, M, true)
    # Algorithm setting
    algorithm_type, alpha, beta = select_algorithm(algorithm, alpha, beta)
    # directory setting
    if logdir isa String
        if !isdir(logdir)
            mkpath(logdir)
        end
    end
    return alpha,
    beta,
    graphv,
    l1u,
    l1v,
    l2u,
    l2v,
    U,
    V,
    L,
    N,
    M,
    numepoch,
    chunksize,
    algorithm_type,
    logdir,
    lower,
    upper
end
