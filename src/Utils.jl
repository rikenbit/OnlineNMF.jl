# Types
struct NMF end
struct DNMF end
struct SPARSE_NMF end
struct SPARSE_DNMF end
struct ALPHA end
struct BETA end

# Helper functions
function load_or_zero(init, nums)
    if init === nothing
        return zeros(nums, nums)
    elseif init isa String
        mat = read_csv(init, Float32)
        return mat[1:nums, 1:nums]
    else
        error("Invalid input for initialization")
    end
end

function load_or_random(init, rows, cols, asym::Bool=false)
    if init === nothing
        mat = rand(Float32, rows, cols)
    elseif init isa String
        mat = read_csv(init, Float32)
        mat = mat[:, 1:cols]
    else
        error("Invalid input for initialization")
    end
    if asym
        mat = (mat + mat') / 2
    end
    return mat
end

# Algorithm Selection
function select_algorithm(algorithm::AbstractString, alpha::Number, beta::Number)
    valid_algorithms =
        ("pearson", "hellinger", "neyman", "alpha", "frobenius", "kl", "is", "beta")

    if algorithm ∉ valid_algorithms
        throw(
            ArgumentError(
                "Invalid algorithm: \"$algorithm\". Must be one of: $(join(valid_algorithms, ", "))",
            ),
        )
    end

    if algorithm in ("pearson", "hellinger", "neyman", "alpha")
        algorithm = ALPHA()
        alpha = if algorithm == "pearson"
            2
        elseif algorithm == "hellinger"
            0.5
        elseif algorithm == "neyman"
            -1
        else
            alpha
        end
    elseif algorithm in ("frobenius", "kl", "is", "beta")
        algorithm = BETA()
        beta = if algorithm == "frobenius"
            2
        elseif algorithm == "kl"
            1
        elseif algorithm == "is"
            0
        else
            beta
        end
    end
    return algorithm, alpha, beta
end

# Rho function (Beta-divergence)
function rho(beta; root=false)
    if root
        return 0.5
    else
        if beta < 1
            return 1 / (2 - beta)
        elseif 1 <= beta && beta <= 2
            return 1
        elseif beta > 2
            return 1 / (beta - 1)
        end
    end
end

# Check NaN value
function checkNaN(X::AbstractArray)
    if any(isnan, X)
        error("NaN values are generated. Select other stepsize")
    end
end

# Output the result of NMF/DNMF
function output(outdir::AbstractString, out::Tuple, lower::Number)
    write_csv(joinpath(outdir, "U.csv"), out[1])
    write_csv(joinpath(outdir, "V.csv"), out[2])
    write_csv(joinpath(outdir, "RecError.csv"), out[3])
    if out[3] < lower && out[4] == 1
        touch(joinpath(outdir, "Converged"))
    end
end

write_csv(filename::AbstractString, data) = writedlm(filename, data, ',')
read_csv(filename::AbstractString) = readdlm(filename, ',')
read_csv(filename::AbstractString, ::Type{T}) where {T} = readdlm(filename, ',', T)

# Parse command line options
function parse_commandline(nmfmodel::Union{NMF,SPARSE_NMF})
    s = ArgParseSettings()

    @add_arg_table s begin
        "--input", "-i"
        help = "Julia Binary file generated by `OnlinePCA.csv2bin` function."
        arg_type = AbstractString
        required = true
        "--outdir", "-o"
        help = "The directory user want to save the result."
        arg_type = AbstractString
        default = "."
        required = false
        "--alpha", "-a"
        help = "The parameter of Alpha-divergence."
        arg_type = Union{Number,AbstractString}
        default = 1
        "--beta", "-b"
        help = "The parameter of Beta-divergence."
        arg_type = Union{Number,AbstractString}
        default = 2
        "--graphv", help = "Graph regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l1u", help = "L1-regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l1v", help = "L1-regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l2u", help = "L2-regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l2u", help = "L2-regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--dim", "-d"
        help = "The number of dimension of NMF."
        arg_type = Union{Number,AbstractString}
        default = 3
        "--numepoch", "-e"
        help = "The number of epochs."
        arg_type = Union{Number,AbstractString}
        default = 5
        "--chunksize", "-c"
        help = "The number of rows reading at once (e.g. 5000)."
        arg_type = Union{Number,AbstractString}
        default = 1
        "--lower"
        help = "Stopping Criteria (When the relative change of error is below this value, the calculation is terminated)."
        arg_type = Union{Number,AbstractString}
        default = 0
        "--upper"
        help = "Stopping Criteria (When the relative change of error is above this value, the calculation is terminated)."
        arg_type = Union{Number,AbstractString}
        default = 1.0f+38
        "--initU"
        help = "The CSV file saving the initial values of factor matrix U."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--initV"
        help = "The CSV file saving the initial values of factor matrix V."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--initL"
        help = "The CSV file saving the initial values of graph Laplacian L."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--logdir", "-l"
        help = "The directory where intermediate files are saved, in every epoch."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
    end

    return parse_args(s)
end

# Parse command line options
function parse_commandline(nmfmodel::Union{DNMF,SPARSE_DNMF})
    s = ArgParseSettings()

    @add_arg_table s begin
        "--input", "-i"
        help = "Julia Binary file generated by `OnlinePCA.csv2bin` function."
        arg_type = AbstractString
        required = true
        "--outdir", "-o"
        help = "The directory user want to save the result."
        arg_type = AbstractString
        default = "."
        required = false
        "--beta", "-b"
        help = "The parameter of Beta-divergence."
        arg_type = Union{Number,AbstractString}
        default = 2
        "--binu", help = "Binary {0,1} regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--binv", help = "Binary {0,1} regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--teru", help = "Ternary {0,1,2} regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--terv", help = "Ternary {0,1,2} regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--graphv", help = "Graph regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l1u", help = "L1-regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l1v", help = "L1-regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l2u", help = "L2-regularization parameter for the factor matrix U."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--l2u", help = "L2-regularization parameter for the factor matrix V."
        arg_type = Union{Number,AbstractString}
        default = eps(Float32)
        "--dim", "-d"
        help = "The number of dimension of NMF."
        arg_type = Union{Number,AbstractString}
        default = 3
        "--numepoch", "-e"
        help = "The number of epochs."
        arg_type = Union{Number,AbstractString}
        default = 5
        "--chunksize", "-c"
        help = "The number of rows reading at once (e.g. 5000)."
        arg_type = Union{Number,AbstractString}
        default = 1
        "--lower"
        help = "Stopping Criteria (When the relative change of error is below this value, the calculation is terminated)."
        arg_type = Union{Number,AbstractString}
        default = 0
        "--upper"
        help = "Stopping Criteria (When the relative change of error is above this value, the calculation is terminated)."
        arg_type = Union{Number,AbstractString}
        default = 1.0f+38
        "--initU"
        help = "The CSV file saving the initial values of factor matrix U."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--initV"
        help = "The CSV file saving the initial values of factor matrix V."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--initL"
        help = "The CSV file saving the initial values of graph Laplacian L."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
        "--logdir", "-l"
        help = "The directory where intermediate files are saved, in every epoch."
        arg_type = Union{Nothing,AbstractString}
        default = nothing
    end

    return parse_args(s)
end

# Return N, M (Zstandard)
function nm(input::AbstractString)
    N = zeros(UInt32, 1)
    M = zeros(UInt32, 1)
    open(input) do file
        stream = ZstdDecompressorStream(file)
        read!(stream, N)
        read!(stream, M)
        close(stream)
    end
    return N[], M[]
end

# Output log file
function outputlog(
    s::Number,
    input::AbstractString,
    logdir::AbstractString,
    U::AbstractArray,
    V::AbstractArray,
    lower::Number,
    upper::Number,
    nmfmodel::Union{NMF,DNMF,SPARSE_NMF,SPARSE_DNMF},
    chunksize::Number,
)
    stop = 0
    E = RecError(input, U, V, nmfmodel, chunksize)
    if s != 1
        old_E = read_csv(joinpath(logdir, "RecError_Epoch" * string(s - 1) * ".csv"))
        RelChange = abs(E - Float32(old_E[1, 2])) / E
        E = ["RecError" => E, "RelChange" => RelChange]
        if RelChange < lower
            println(
                "Relative change of reconstruction error is below the lower value (no change)",
            )
            stop = 1
        end
        if RelChange > upper
            println(
                "Relative change of reconstruction error is above the upper value (unstable)",
            )
            stop = 2
        end
    else
        E = ["RecError" => E]
    end
    write_csv(joinpath(logdir, "RecError_Epoch" * string(s) * ".csv"), E)
    write_csv(joinpath(logdir, "U_Epoch" * string(s) * ".csv"), U)
    write_csv(joinpath(logdir, "V_Epoch" * string(s) * ".csv"), V)
    return stop
end

# Reconstuction Error
function RecError(
    input::AbstractString,
    U::AbstractArray,
    V::AbstractArray,
    nmfmodel::Union{NMF,DNMF},
    chunksize::Number,
)
    N = zeros(UInt32, 1)
    M = zeros(UInt32, 1)
    E = 0.0f0
    open(input) do file
        stream = ZstdDecompressorStream(file)
        read!(stream, N)
        read!(stream, M)
        N, M = N[], M[]
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            X_batch = zeros(UInt32, batch_size, M)
            read!(stream, X_batch)
            U_batch = @view U[n:n+batch_size-1, :]
            E += Float32(sum((X_batch - U_batch * V') .^ 2))
            n += batch_size
        end
        close(stream)
    end
    @assert E isa Float32
    return E
end

function RecError(
    input::AbstractString,
    U::AbstractArray,
    V::AbstractArray,
    nmfmodel::Union{SPARSE_NMF,SPARSE_DNMF},
    chunksize::Number,
)
    N = zeros(UInt32, 1)
    M = zeros(UInt32, 1)
    E = 0.0f0
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        read!(stream, N)
        read!(stream, M)
        N, M = N[], M[]
        overflow_buf = UInt32[]
        n = 1
        while n <= N
            batch_size = min(chunksize, N - n + 1)
            max_size = (batch_size + 1) * M # For overflow
            rows = zeros(UInt32, max_size)
            cols = zeros(UInt32, max_size)
            vals = zeros(UInt32, max_size)
            count = 0
            ############### Overflow buffer ###############
            if length(overflow_buf) > 0
                count += 1
                # Re-mapping row index
                rows[count] = overflow_buf[1] - n + 1
                cols[count] = overflow_buf[2]
                vals[count] = overflow_buf[3]
                empty!(overflow_buf)
            end
            ###############################################
            while !eof(stream)
                buf = zeros(UInt32, 3)
                read!(stream, buf)
                row, col, val = buf[1], buf[2], buf[3]
                if n ≤ row < n + batch_size
                    count += 1
                    # Re-mapping row index
                    rows[count] = row - n + 1
                    cols[count] = col
                    vals[count] = val
                else
                    overflow_buf = buf
                    break
                end
            end
            # Remove 0s from the end
            resize!(rows, count)
            resize!(cols, count)
            resize!(vals, count)
            if count > 0
                X_chunk = sparse(rows, cols, vals, batch_size, M)
            else
                X_chunk = spzeros(batch_size, M)
            end
            U_chunk = @view U[n:n+batch_size-1, :]
            E += Float32(sum((Matrix(X_chunk) - U_chunk * V') .^ 2))
            n += batch_size
        end
        close(stream)
    end
    @assert E isa Float32
    return E
end
