# Types
struct NMF end
struct DNMF end
struct SPARSE_NMF end
struct SPARSE_DNMF end
struct ALPHA end
struct BETA end

function load_or_zero(init, nums)
    if init == nothing
        return zeros(nums, nums)
    elseif init isa String
        mat = read_csv(init, Float32)
        return mat[1:nums, 1:nums]
    else
        error("Invalid input for initialization")
    end
end

function load_or_random(init, rows, cols)
    if init == nothing
        return rand(Float32, rows, cols)
    elseif init isa String
        mat = read_csv(init, Float32)
        return mat[:, 1:cols]
    else
        error("Invalid input for initialization")
    end
end

# Algorithm Selection
function select_algorithm(algorithm::AbstractString, alpha::Number, beta::Number)
    valid_algorithms = ("pearson", "hellinger", "neyman", "alpha", "frobenius", "kl", "is", "beta")
    
    if algorithm ∉ valid_algorithms
        throw(ArgumentError("Invalid algorithm: \"$algorithm\". Must be one of: $(join(valid_algorithms, ", "))"))
    end

    if algorithm in ("pearson", "hellinger", "neyman", "alpha")
        algorithm = ALPHA()
        alpha = if algorithm == "pearson"
            2
        elseif algorithm == "hellinger"
            0.5
        elseif algorithm == "neyman"
            -1
        else
            alpha  # alphaは変更しない
        end
    elseif algorithm in ("frobenius", "kl", "is", "beta")
        algorithm = BETA()
        beta = if algorithm == "frobenius"
            2
        elseif algorithm == "kl"
            1
        elseif algorithm == "is"
            0
        else
            beta  # betaは変更しない
        end
    end
    return algorithm, alpha, beta
end

# Rho function (Beta-divergence)
function rho(beta; root=false)
    if root
        return 0.5
    else
        if beta < 1
            return 1 / (2 - beta)
        elseif 1 <= beta && beta <= 2
            return 1
        elseif beta > 2
            return 1 / (beta - 1)
        end
    end
end

# Check NaN value
function checkNaN(X::AbstractArray)
    if any(isnan, X)
        error("NaN values are generated. Select other stepsize")
    end
end

# Output the result of NMF/DNMF
function output(outdir::AbstractString, out::Tuple, lower::Number)
    write_csv(joinpath(outdir, "U.csv"), out[1])
    write_csv(joinpath(outdir, "V.csv"), out[2])
    write_csv(joinpath(outdir, "RecError.csv"), out[3])
    if out[3] < lower && out[4] == 1
        touch(joinpath(outdir, "Converged"))
    end
end

write_csv(filename::AbstractString, data) = writedlm(filename, data, ',')
read_csv(filename::AbstractString) = readdlm(filename, ',')
read_csv(filename::AbstractString, ::Type{T}) where {T} = readdlm(filename, ',', T)

# Parse command line options
function parse_commandline(nmfmodel::Union{NMF,SPARSE_NMF})
    s = ArgParseSettings()

    @add_arg_table s begin
        "--input", "-i"
            help = "Julia Binary file generated by `OnlinePCA.csv2bin` function."
            arg_type = AbstractString
            required = true
        "--outdir", "-o"
            help = "The directory user want to save the result."
            arg_type = AbstractString
            default = "."
            required = false
        "--alpha", "-a"
            help = "The parameter of Alpha-divergence."
            arg_type = Union{Number,AbstractString}
            default = 1
        "--beta", "-b"
            help = "The parameter of Beta-divergence."
            arg_type = Union{Number,AbstractString}
            default = 2
        "--l1u",
            help = "L1-regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l1v",
            help = "L1-regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l2u",
            help = "L2-regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l2u",
            help = "L2-regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--dim", "-d"
            help = "The number of dimension of NMF."
            arg_type = Union{Number,AbstractString}
            default = 3
        "--numepoch", "-e"
            help = "The number of epochs."
            arg_type = Union{Number,AbstractString}
            default = 5
        "--chunksize", "-c"
            help = "The number of rows reading at once (e.g. 5000)."
            arg_type = Union{Number,AbstractString}
            default = 1
        "--lower"
            help = "Stopping Criteria (When the relative change of error is below this value, the calculation is terminated)."
            arg_type = Union{Number,AbstractString}
            default = 0
        "--upper"
            help = "Stopping Criteria (When the relative change of error is above this value, the calculation is terminated)."
            arg_type = Union{Number,AbstractString}
            default = 1.0f+38
        "--initU"
            help = "The CSV file saving the initial values of factor matrix U."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
        "--initV"
            help = "The CSV file saving the initial values of factor matrix V."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
        "--logdir", "-l"
            help = "The directory where intermediate files are saved, in every epoch."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
    end

    return parse_args(s)
end

# Parse command line options
function parse_commandline(nmfmodel::Union{DNMF,SPARSE_DNMF})
    s = ArgParseSettings()

    @add_arg_table s begin
        "--input", "-i"
            help = "Julia Binary file generated by `OnlinePCA.csv2bin` function."
            arg_type = AbstractString
            required = true
        "--outdir", "-o"
            help = "The directory user want to save the result."
            arg_type = AbstractString
            default = "."
            required = false
        "--beta", "-b"
            help = "The parameter of Beta-divergence."
            arg_type = Union{Number,AbstractString}
            default = 2
            "--binu",
            help = "Binary {0,1} regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--binv",
            help = "Binary {0,1} regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--teru",
            help = "Ternary {0,1,2} regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--terv",
            help = "Ternary {0,1,2} regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--graphv",
            help = "Graph regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l1u",
            help = "L1-regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l1v",
            help = "L1-regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l2u",
            help = "L2-regularization parameter for the factor matrix U."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--l2u",
            help = "L2-regularization parameter for the factor matrix V."
            arg_type = Union{Number,AbstractString}
            default = eps(Float32)
        "--dim", "-d"
            help = "The number of dimension of NMF."
            arg_type = Union{Number,AbstractString}
            default = 3
        "--numepoch", "-e"
            help = "The number of epochs."
            arg_type = Union{Number,AbstractString}
            default = 5
        "--chunksize", "-c"
            help = "The number of rows reading at once (e.g. 5000)."
            arg_type = Union{Number,AbstractString}
            default = 1
        "--lower"
            help = "Stopping Criteria (When the relative change of error is below this value, the calculation is terminated)."
            arg_type = Union{Number,AbstractString}
            default = 0
        "--upper"
            help = "Stopping Criteria (When the relative change of error is above this value, the calculation is terminated)."
            arg_type = Union{Number,AbstractString}
            default = 1.0f+38
        "--initU"
            help = "The CSV file saving the initial values of factor matrix U."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
        "--initV"
            help = "The CSV file saving the initial values of factor matrix V."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
        "--initL"
            help = "The CSV file saving the initial values of graph Laplacian L."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
        "--logdir", "-l"
            help = "The directory where intermediate files are saved, in every epoch."
            arg_type = Union{Nothing,AbstractString}
            default = nothing
    end

    return parse_args(s)
end

# Return N, M (Zstandard)
function nm(input::AbstractString, nmfmodel::Union{NMF,DNMF})
    N = zeros(UInt32, 1)
    M = zeros(UInt32, 1)
    open(input) do file
        stream = ZstdDecompressorStream(file)
        read!(stream, N)
        read!(stream, M)
        close(stream)
    end
    return N[], M[]
end

# Return N, M (Zstandard + Matrix Market)
function nm(input::AbstractString, nmfmodel::Union{SPARSE_NMF,SPARSE_DNMF})
    open(input, "r") do file
        stream = ZstdDecompressorStream(file)
        while !eof(stream)
            line = readline(stream)
            if !startswith(line, "%")
                dims = parse.(Int, split(line))
                close(stream)
                return dims[1], dims[2]
            end
        end
        close(stream)
        error("Invalid Matrix Market file format: No valid header found")
    end
end

# Output log file
function outputlog(s::Number, input::AbstractString, logdir::AbstractString, U::AbstractArray, V::AbstractArray, lower::Number, upper::Number, nmfmodel::Union{NMF,DNMF})
    stop = 0
    E = RecError(input, U, V, nmfmodel)
    if s != 1
        old_E = read_csv(joinpath(logdir, "RecError_Epoch"*string(s-1)*".csv"))
        RelChange = abs(E - Float32(old_E[1,2])) / E
        E = ["RecError" => E, "RelChange" => RelChange]
        if RelChange < lower
            println("Relative change of reconstruction error is below the lower value (no change)")
            stop = 1
        end
        if RelChange > upper
            println("Relative change of reconstruction error is above the upper value (unstable)")
            stop = 2
        end
    else
        E = ["RecError" => E]
    end
    write_csv(joinpath(logdir, "RecError_Epoch"*string(s)*".csv"), E)
    write_csv(joinpath(logdir, "U_Epoch"*string(s)*".csv"), U)
    write_csv(joinpath(logdir, "V_Epoch"*string(s)*".csv"), V)
    return stop
end

# Reconstuction Error
function RecError(input::AbstractString, U::AbstractArray, V::AbstractArray,     nmfmodel::Union{NMF,DNMF})
    N, M = nm(input, nmfmodel)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    x = zeros(UInt32, M)
    E = 0.0f0
    open(input) do file
        stream = ZstdDecompressorStream(file)
        read!(stream, tmpN)
        read!(stream, tmpM)
        for n = 1:N
            # Data Import
            read!(stream, x)
            E += Float32(sum((x' - U[n:n, :] * V').^2))
        end
        close(stream)
    end
    @assert E isa Float32
    # Return
    return E
end
